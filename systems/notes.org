#+TITLE: Systems Notes

#+OPTIONS: toc:nil

* Table of Contents                                       :TOC_2_gh:noexport:
- [[#signal-handling----11242019][Signal Handling -- 11/24/2019]]
  - [[#sending-mixed-signals][Sending Mixed Signals]]
- [[#executive-decisions----11252019][Executive Decisions -- 11/25/2019]]
  - [[#the-exec--family---unistdh][The Exec  family - <unistd.h>]]
  - [[#strsep---stringh][strsep - <string.h>]]
  - [[#terminal-info][Terminal Info]]
- [[#managing-sub-processes----11262019][Managing Sub-Processes -- 11/26/2019]]
  - [[#fork----unistdh][fork -- unistd.h]]
  - [[#wait----syswaith][wait -- <sys/wait.h>]]
- [[#navigating-the-shell----12032019][Navigating The Shell -- 12/03/2019]]
  - [[#commands-that-cant-work-in-sub-processes][Commands that can't work in sub processes]]
  - [[#syntax][Syntax]]

* Signal Handling -- 11/24/2019
** Sending Mixed Signals
*** Signal handling in c programs <signal.h>
- sighandler
- To intercept signals in a c program, you must create a signal 
handling function.
- Some signals (like SIGKILL, SIGSTOP) cannot be caught
#+BEGIN_SRC c
static void sighandler(int signo)
#+END_SRC
- Static values in c exist outside the normal call stack, 
they can be accessed regardless of the function on top
- For variables, this also means they retain their values even if
the function they are declared in has ended.
- Static variables (variables and functions) can only 
be accessed from within the file they are declared
#+BEGIN_SRC c
static void sighandler(int signo) {
  if(signo == SIGINT) prinf("haha! can't touch this!\n");
  if(signo == SIGSEV) printf("nothing to see here..\n");
}

int main() {
  signal(SIGINT, sighandler);
  signal(SIGSEGV, sighandler);
}
#+END_SRC
#+BEGIN_SRC c
exit(0); exit(1); //Exits program, use exit(1) if error
#+END_SRC

* Executive Decisions -- 11/25/2019
** The Exec  family - <unistd.h>
A group of c functions that can be used to run other programs.

*** execl
#+BEGIN_SRC c
/**
 * Replaces the current process with the new program
 * @param path Path of command
 * @param command Name of program
 * @param arg0 command line args to give to prog (-a, -l). Ends with NULL
 */
execl(char *path, char *command, char *arg0, arg1 _ NULL)
execl("/bin/ls", "ls", "-a", "-l", NULL);
#+END_SRC

*** execlp
#+BEGIN_SRC c
/**
 * Basically execl, except it will check PATH
 */
execlp(path, command, arg0, arg1);
execlp("ls", "ls", "-a", "-l", NULL);
#+END_SRC

*** execvp

#+BEGIN_SRC c
/**
 * @param argument_array - Array of strings containing the arguments to command.
 * argument_array[0] must be the name of command 
*/
execvp(path, argument_array);
char *cmd[4] = {"ls", "-a", "-l", NULL};
execvp(cmd[0], cmd);
#+END_SRC
** strsep - <string.h>
*** strsep
Parse a string with a common delimiter
#+BEGIN_SRC c
/**
 * Locates the first occurence of any specified delimiters in a string and 
 * replaces it with NULL
 * @param source - set to string starting at 1 index past new NULL
                   char ** because will modify actual value
		   char is "w", char * is pointer to "w", char ** is actual
		     thing char points to
 * @param delimiters - each char interpreted as a distinct delimiter
 * @return beginning of the original string
 */
strsep(char **source, char *delimiters)
#+END_SRC

*** Example
Replaces the "-" after woah with NULL
returns a pointer to the "w" in "woah"
sets curr to point to the t in "this-is-cool"
#+BEGIN_SRC c
char line[100] = "woah-this-is-cool";
char *curr = line;
char *token;
token = strsep(&curr,"-"); //token = "woah", curr = "this-is-cool"
#+END_SRC

** Terminal Info
#+BEGIN_SRC shellscript
which ls # prints out the directory ls is located in
# Always prints out the one that's run when you type the script
./hello # Tells the terminal not to search PATH for script
#+END_SRC

* Managing Sub-Processes -- 11/26/2019
** fork -- unistd.h
#+BEGIN_SRC c
  #include <unistd.h>

  /**
   ,* Creates a child subprocess (duplicate of parent -- stack and heap copied)
   ,* @return 0 & child's pid, or -1 (errno) to parent
  ,*/
  fork()

  //example
  #include <stdio.h>
  printf("pre-fork pid: %d", getpid());
  f = fork();
  int status;
  if(f) {
    printf("parent pid: %d, f: %d\n", getpid(), f);
    child = wait(&status)
    printf("wait returned: %d status: %d return value: %d\n", child, status, WEXITSTATUS(status));
    // Will also return the signal it got (11 = segfault)
  } else {
    printf("child pid: %d, parent: %d f: %d\n", getpid(), getppid(), f);
    // if getppid() returns 1, then it is an orphan process -- no parent process
    // 1 is the orphan process that is always running
  }
#+END_SRC
** wait -- <sys/wait.h>

#+BEGIN_SRC c
#include <sys/wait.h>

/**
 * Stops a child process from running until any child has exited
 * @param status - Represented by 4 bytes, base 256
 * @return - Returns pid of child that exited, or -1 (errno) + gathers info about child process (reaping)
 *           IF multiple child processes exit, rand one will be reaped
*/
wait(status)
#+END_SRC
*** Status macros
#+BEGIN_SRC c
MACRO(status)
WIFEEXITED // True if child exited normally
WEXITSTATUS // The return value of the child
WIFSIGNALLED // True if child exited due to a signal
WTERMSIG
#+END_SRC
* Navigating The Shell -- 12/03/2019
** Commands that can't work in sub processes
cd & exit -- Both are designed to edit the parent process.
(calling cd on a child process won't change the directory)
** Syntax
; means the same thing that it does in java/c
pipeline taks the input of one thing, and passes it on to the next
* Pipe
A conduit between 2 separate processes on the same computer
Pipes have 2 ends, a read end and a write end
Pipes exist in memory
** pipe - <unistd.h>
#+BEGIN_SRC c
/**
 * Create an unnamed pipe
 * @return 0 if the pipe was created, -1 if not
*/
pipe(int descriptors[2])
#+END_SRC
*** Example Code
#+BEGIN_SRC c
#define READ 0
#define WRITE 1
int fds[2];
pipe(fds);

printf("fds[0]: %d\n", fds[0]);
printf("fds[1]: %d\n", fds[1]);

f = fork();
if(f) {
  char line[100];
  printf("parent: getting info from child...\n");
  read(fds[READ], line, sizeof(line));
  printf("parent: received [%s]\n", line);
} else P
  printf("child: sending info to parent. \n");
  sleep(10);
  write(fds[WRITE], "hello!", 7);
}
#+END_SRC
